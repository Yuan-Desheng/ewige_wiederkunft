---
doc_type: weread-highlights-reviews
bookId: "22806945"
reviewCount: 0
noteCount: 10
author: 凯尔辛普森
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/945/22806945/t6_22806945.jpg
progress: 9%
readingTime: 2小时17分钟
readingDate: 2021-12-21
isbn: 9787115385734
lastReadDate: 2022-08-15
description: 很多人对JavaScript这门语言的印象都是简单易学，很容易上手。JavaScript语言本身有很多复杂的概念，语言的使用者不必深入理解这些概念也可以编写出功能全面的应用。殊不知，这些复杂精妙的概念才是语言的精髓，即使是经验丰富的JavaScript开发人员，如果没有认真学习的话也无法真正理解它们。在本书中，我们要直面当前JavaScript开发者不求甚解的大趋势，深入理解语言内部的机制。本书既适合JavaScript语言初学者阅读，又适合经验丰富的JavaScript开发人员深入学习。
发行日期: 2015-04-01 00:00:00
title: 你不知道的JavaScript（上卷）
tags: 电子书
出版社: 人民邮电出版社
imageData: https://wfqqreader-1252317822.image.myqcloud.com/cover/945/22806945/t6_22806945.jpg

---

``````ad-flex 
`````col
````col-md
flexGrow=0.7
===
`VIEW[{imageData}][image]`
````
`````col
````col-md
flexGrow=1
===
书名：`INPUT[text(class(text-70)):title]` 
作者：`INPUT[text(class(text-70)):author]` 
出版：`INPUT[text(class(text-70)):出版社]` 
进度：`INPUT[inlineSelect(option(在读), option(已读), option(未读)):status]` `INPUT[slider(addLabels):progress]`
类型：`INPUT[inlineSelect(option(论文), option(电子书), option(合同), option(其他文档)):tags]` 发行：`INPUT[datePicker:发行日期]` 
评分：`INPUT[inlineSelect(option(⭐), option(⭐⭐), option(⭐⭐⭐), option(⭐⭐⭐⭐), option(⭐⭐⭐⭐⭐), option(⭐⭐⭐⭐⭐⭐), option(⭐⭐⭐⭐⭐⭐⭐), option(⭐⭐⭐⭐⭐⭐⭐⭐), option(⭐⭐⭐⭐⭐⭐⭐⭐⭐), option(⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐)):评价]`
书籍简介：
`INPUT[textArea(class(textArea-270)):description]`
````
`````
````col-md
flexGrow=1
===
✏️Thoughts/读后感 
```meta-bind-embed
[[横格输入模块-textArea-4行]]
```
````
``````


### 划线22806945-11-2577-2613
📌 当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。 
⏱ 2022-08-14 08:12:30 ^22806945-11-2577-2613

### 划线22806945-11-2650-2770
📌 RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。 
⏱ 2022-08-14 08:13:05 ^22806945-11-2650-2770

### 划线22806945-11-3465-3500
📌 “赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。 
⏱ 2022-08-14 08:16:23 ^22806945-11-3465-3500


### 划线22806945-12-495-596
📌 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 
⏱ 2022-08-14 09:54:27 ^22806945-12-495-596

### 划线22806945-12-1219-1301
📌 遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。 
⏱ 2022-08-14 09:59:40 ^22806945-12-1219-1301


### 划线22806945-13-470-516
📌 因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。 
⏱ 2022-08-14 10:00:58 ^22806945-13-470-516

### 划线22806945-13-821-871
📌 如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。 
⏱ 2022-08-15 10:06:02 ^22806945-13-821-871

### 划线22806945-13-1457-1521
📌 ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 
⏱ 2022-08-15 10:23:41 ^22806945-13-1457-1521


### 划线22806945-14-450-575
📌 如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。赋值操作符会导致LHS查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 
⏱ 2022-08-15 10:54:57 ^22806945-14-450-575

### 划线22806945-14-800-1050
📌 LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。 
⏱ 2022-08-15 10:55:17 ^22806945-14-800-1050

