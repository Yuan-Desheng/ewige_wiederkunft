---
searchText: ""
searchTag: ""
maxline: 50
currentPage: 1
areaPath: Documents/I.P.A.R.A
startDate: ""
endDate: ""
showPermanentNotes: true
showProjectNotes: true
showFlashNotes: true
topicCardFilter: ""
---

ðŸ”`INPUT[text(placeholder(ç¬”è®°å|æ”¯æŒ"ä¸Žæˆ–éž")):searchText]` ðŸ”“é—ªå¿µç¬”è®°`INPUT[toggle:showFlashNotes]` é¡¹ç›®ç¬”è®°`INPUT[toggle:showProjectNotes]` æ°¸ä¹…ç¬”è®°`INPUT[toggle:showPermanentNotes]` 
ðŸ·ï¸`INPUT[text(placeholder(æ ‡ç­¾å|æ”¯æŒ"ä¸Žæˆ–éž")):searchTag]` ðŸ“… `INPUT[datePicker(defaultValue(null)):startDate]`âž¡ï¸ `INPUT[datePicker(defaultValue(null)):endDate]` è¡Œæ•° `INPUT[slider(addLabels):maxline]`
ðŸ”†é€‰é¢†åŸŸ`INPUT[inlineSelect(option(Documents/I.P.A.R.A,æ‰€æœ‰é¢†åŸŸ), option(Documents/I.P.A.R.A/å­¦ä¹ é¢†åŸŸ,å­¦ä¹ é¢†åŸŸ), option(Documents/I.P.A.R.A/å·¥ä½œé¢†åŸŸ,å·¥ä½œé¢†åŸŸ),option(Documents/I.P.A.R.A/ç”Ÿæ´»é¢†åŸŸ,ç”Ÿæ´»é¢†åŸŸ)):areaPath]`  ðŸ”°é€‰ä¸»é¢˜`BUTTON[topic-filter]`   ðŸ”˜é‡ç½®æ¡ä»¶ `BUTTON[resetDatabase]`  
```dataviewjs
const currentFile = dv.page(dv.current().file.path);
const fileContent = await dv.io.load(dv.current().file.path);
const frontMatterMatch = fileContent.match(/^---\n([\s\S]*?)\n---/);
let frontMatter = frontMatterMatch ? frontMatterMatch[1] : '';
const updateTagSearch = async (tag) => {
    const newFrontMatter = frontMatter.replace(/searchTag: .*$/m, `searchTag: "${tag}"`);
    const newContent = fileContent.replace(/^---\n[\s\S]*?\n---/, `---\n${newFrontMatter}\n---`);
    await app.vault.modify(app.workspace.getActiveFile(), newContent);
};

const updateSearchTag = (tag) => {
    const searchTagInput = dv.container.querySelector('#searchTagInput');
    if (searchTagInput) {
        searchTagInput.value = tag;
        const event = new Event('input', { bubbles: true });
        searchTagInput.dispatchEvent(event);
        dv.container.dispatchEvent(new CustomEvent('dvjs-update'));
    }
};

const config = {
    searchText: dv.current().searchText || "",
    searchTag: dv.current().searchTag || "",
    maxline: dv.current().maxline || 50,  
    currentPage: dv.current().currentPage || 1,  
    areaPath: dv.current().areaPath || "Documents/I.P.A.R.A",
    startDate: dv.current().startDate,
    endDate: dv.current().endDate,
    showPermanentNotes: dv.current().showPermanentNotes ?? false,
    showProjectNotes: dv.current().showProjectNotes ?? false,
    showFlashNotes: dv.current().showFlashNotes ?? false,
    topicCardFilter: dv.current().topicCardFilter || "",
    enableTopicFilter: dv.current().enableTopicFilter ?? true  
};

const SearchParser = {
    parse(text) {
        if (!text || !text.trim()) return null;
        return text.split('|')
            .map(term => term.trim())
            .map(term => term.split(' ')
                .filter(Boolean)
                .map(t => ({
                    term: t.startsWith('-') ? t.slice(1).toLowerCase() : t.toLowerCase(),
                    negated: t.startsWith('-')
                }))
            );
    },

    matches(target, terms) {
        if (!terms) return true;
        if (Array.isArray(target)) {
            return this.matchesArray(target, terms);
        }
        const targetLower = target.toLowerCase();
        return terms.some(andGroup => 
            andGroup.every(({term, negated}) => 
                negated !== targetLower.includes(term)
            )
        );
    },
    matchesArray(targetArray, terms) {
        if (!terms) return true;
        if (!targetArray || targetArray.length === 0) return false;
        const targetLower = targetArray.map(tag => String(tag).toLowerCase());
        
        return terms.some(andGroup => 
            andGroup.every(({term, negated}) => {
                const hasMatch = targetLower.some(tag => tag.includes(term));
                return negated !== hasMatch;
            })
        );
    }
};

const DateUtils = {
    isInRange(dateStr, start, end) {
        if (!start && !end) return true;
        if (!dateStr) return true;

        const date = new Date(dateStr);
        if (isNaN(date.getTime())) return true;

        const time = date.getTime();
        const startTime = start ? new Date(start).getTime() : -Infinity;
        const endTime = end ? new Date(end).getTime() : Infinity;

        return time >= startTime && time <= endTime;
    },
    format(date) {
        if (!date) return '<div style="white-space: nowrap; min-width: 120px; display: block;">ðŸ”´ æœªè®¾ç½®</div>';
        try {
            const d = new Date(date);
            if (isNaN(d.getTime())) {
                return '<div style="white-space: nowrap; min-width: 120px; display: block;">ðŸ”´ æ— æ•ˆæ—¥æœŸ</div>';
            }
            
            const offsetDate = new Date(d.getTime() + (24 * 60 * 60 * 1000));
            const formatted = offsetDate.toISOString().split('T')[0];
            return `<div style="white-space: nowrap; min-width: 120px; display: block;">ðŸŸ¢ ${formatted}</div>`;
        } catch {
            return '<div style="white-space: nowrap; min-width: 120px; display: block;">ðŸ”´ æ— æ•ˆæ—¥æœŸ</div>';
        }
    }
};

const TagUtils = {
    colors: ['#7C9D96', '#A9B388', '#B99470', '#94A684', '#8B7E74', '#9EB384', '#435334', '#6C7171', '#897E6F', '#819595'],
    
    getColor(tag) {
        let hash = Array.from(tag).reduce((acc, char) => 
            char.charCodeAt(0) + ((acc << 5) - acc), 0);
        return this.colors[Math.abs(hash) % this.colors.length];
    },

    format(tags) {
        const normalizedTags = normalizeTagsForDisplay(tags);
        if (!normalizedTags || normalizedTags.length === 0) {
            return "æ— æ ‡ç­¾";
        }
        
        return normalizedTags.map(tag => {
            if (!tag) return '';
            const color = this.getColor(tag);
            const encodedTag = tag.replace(/"/g, '\\"');
            return `<button
                data-tag="${encodedTag}"
                class="tag-button"
                style="display: inline-block; padding: 2px 8px; margin: 2px; border: none; border-radius: 6px; background-color: ${color}; color: white; font-size: 0.8em; opacity: 0.85; cursor: pointer;">â€¢ ${tag}</button>`;
        }).filter(t => t !== '').join(' ') || "æ— æ ‡ç­¾";
    }
};

const FilterUtils = {
    shouldShowNote(noteType, config) {
        const typeMap = {
            "æ°¸ä¹…ç¬”è®°": config.showPermanentNotes,
            "é¡¹ç›®ç¬”è®°": config.showProjectNotes,
            "é—ªå¿µç¬”è®°": config.showFlashNotes
        };
        return typeMap[noteType] ?? true;
    },

    formatValue(value, defaultText = "æœªè®¾ç½®") {
         return !value ? defaultText : Array.isArray(value) ? value.join(", ") : String(value);
    },
    
    hasTopicCardLink(page, config) {
        if (!config.topicCardFilter) {
            return true;
        }
        
        try {
            const topicLinks = page["å¡ç‰‡ç›’ç¬”è®°ä¸»é¢˜"];
            if (!topicLinks) {
                return false;
            }

            const targetTopicPath = config.topicCardFilter.toLowerCase();

            if (Array.isArray(topicLinks)) {
                return topicLinks.some(link => this.linkContainsTopic(link, targetTopicPath));
            }

            return this.linkContainsTopic(topicLinks, targetTopicPath);
        } catch (error) {
            console.error("è¿‡æ»¤ä¸»é¢˜å¡æ—¶å‡ºé”™:", error, "é¡µé¢:", page.file.name);
            return true; 
        }
    },

    linkContainsTopic(link, targetTopicPath) {
        if (!link) {
            return false;
        }
        
        const linkStr = String(link);

        const linkRegex = /\[\[(.*?)(?:\|(.*?))?\]\]/;
        const match = linkStr.match(linkRegex);
        
        if (!match) {
            return linkStr.toLowerCase().includes(targetTopicPath);
        }

        const linkPath = match[1].toLowerCase();
        
        return linkPath.includes(targetTopicPath);
    }
};

dv.container.updateSearchTag = updateSearchTag;

dv.container.addEventListener('click', async (event) => {
    if (event.target.classList.contains('tag-button')) {
        const tag = event.target.dataset.tag;
        await updateTagSearch(tag);
    }
});

const updateCurrentPage = async (newPage) => {
    const newFrontMatter = frontMatter.replace(/currentPage: .*$/m, `currentPage: ${newPage}`);
    const newContent = fileContent.replace(/^---\n[\s\S]*?\n---/, `---\n${newFrontMatter}\n---`);
    await app.vault.modify(app.workspace.getActiveFile(), newContent);
};

const getNoteTypePriority = (type) => {
    const priorities = {
        "æœªåˆ†ç±»": 0,
        "é—ªå¿µç¬”è®°": 1,
        "é¡¹ç›®ç¬”è®°": 2,
        "æ°¸ä¹…ç¬”è®°": 3
    };
    return priorities[type] ?? 0;
};

// å¢žå¼ºçš„æ ‡ç­¾å¤„ç†å‡½æ•°
const normalizeTagsForSearch = (tags) => {
    if (!tags) return [];
    
    try {
        if (Array.isArray(tags)) {
            return tags.map(tag => {
                if (typeof tag === 'string') {
                    // å¤„ç†å†…éƒ¨é“¾æŽ¥æ ¼å¼ [[xxx]]
                    const linkMatch = tag.match(/\[\[(.*?)(?:\|.*?)?\]\]/);
                    return linkMatch ? linkMatch[1] : tag;
                }
                return String(tag);
            });
        }
        
        if (typeof tags === 'string') {
            // å¤„ç†å­—ç¬¦ä¸²ä¸­çš„å¤šä¸ªå†…éƒ¨é“¾æŽ¥
            const linkMatches = tags.match(/\[\[(.*?)(?:\|.*?)?\]\]/g);
            if (linkMatches) {
                return linkMatches.map(match => match.replace(/\[\[(.*?)(?:\|.*?)?\]\]/, '$1'));
            }
            return tags.trim().split(/\s+/).filter(Boolean);
        }
        
        return [String(tags)];
    } catch (error) {
        console.error("å¤„ç†æ ‡ç­¾æ—¶å‡ºé”™:", error, "æ ‡ç­¾:", tags);
        return [];
    }
};

const normalizeTagsForDisplay = (tags) => {
    if (!tags) return [];
    
    try {
        if (Array.isArray(tags)) {
            return tags.map(tag => {
                if (typeof tag === 'string') {
                    // æå–å†…éƒ¨é“¾æŽ¥çš„æ˜¾ç¤ºæ–‡æœ¬
                    const linkMatch = tag.match(/\[\[(.*?)(?:\|(.*?))?\]\]/);
                    if (linkMatch) {
                        return linkMatch[2] || linkMatch[1]; // ä½¿ç”¨åˆ«åæˆ–æ–‡ä»¶å
                    }
                    return tag;
                }
                return String(tag);
            });
        }
        
        if (typeof tags === 'string') {
            // å¤„ç†å­—ç¬¦ä¸²ä¸­çš„å¤šä¸ªå†…éƒ¨é“¾æŽ¥
            const linkMatches = tags.match(/\[\[(.*?)(?:\|(.*?))?\]\]/g);
            if (linkMatches) {
                return linkMatches.map(match => {
                    const innerMatch = match.match(/\[\[(.*?)(?:\|(.*?))?\]\]/);
                    return innerMatch[2] || innerMatch[1];
                });
            }
            return tags.trim().split(/\s+/).filter(Boolean);
        }
        
        return [String(tags)];
    } catch (error) {
        console.error("å¤„ç†æ˜¾ç¤ºæ ‡ç­¾æ—¶å‡ºé”™:", error, "æ ‡ç­¾:", tags);
        return ["æ ‡ç­¾è§£æžé”™è¯¯"];
    }
};

const searchTerms = SearchParser.parse(config.searchText);
const tagSearchTerms = SearchParser.parse(config.searchTag);

// ä½¿ç”¨try-catchåŒ…è£…ä¸»è¦çš„æŸ¥è¯¢é€»è¾‘
try {
    const allFilteredPages = dv.pages(`"${config.areaPath}"`)
        .where(p => p.file.path.endsWith('.md'))
        .where(p => SearchParser.matches(p.file.name, searchTerms))
        .where(p => SearchParser.matches(normalizeTagsForSearch(p.tags), tagSearchTerms))
        .where(p => FilterUtils.shouldShowNote(p["ç¬”è®°ç±»åž‹"], config))
        .where(p => DateUtils.isInRange(p["é˜è¿°æ—¥æœŸ"], config.startDate, config.endDate))
        .where(p => FilterUtils.hasTopicCardLink(p, config))
        .sort(p => {
            const typePriority = getNoteTypePriority(p["ç¬”è®°ç±»åž‹"]);
            const dateValue = p["é˜è¿°æ—¥æœŸ"] ? new Date(p["é˜è¿°æ—¥æœŸ"]).getTime() : Infinity;
            return [typePriority, dateValue];
        });

    const totalItems = allFilteredPages.length;
    const totalPages = Math.ceil(totalItems / config.maxline) || 1;
    const currentPage = Math.min(Math.max(1, config.currentPage), totalPages);
    const startIndex = (currentPage - 1) * config.maxline;
    const endIndex = startIndex + config.maxline;

    const currentPageData = allFilteredPages.slice(startIndex, endIndex);

    dv.table(["ç¬”è®°åç§°", "ç¬”è®°ç±»åž‹", "ç¬”è®°ä¸»é¢˜", "è¯¦è¿°è®¡åˆ’", "æ ‡ç­¾ï¼ˆå±žæ€§ï¼‰"], 
        currentPageData.map(p => [
            p.file.link,
            `<div style="white-space: nowrap; min-width: 100px; display: block;">${p["ç¬”è®°ç±»åž‹"] || "æœªåˆ†ç±»"}</div>`,
            FilterUtils.formatValue(p["å¡ç‰‡ç›’ç¬”è®°ä¸»é¢˜"], "æœªé“¾æŽ¥"),
            DateUtils.format(p["é˜è¿°æ—¥æœŸ"]),
            TagUtils.format(p.tags)
        ])
    );

    const paginationContainer = dv.container.createEl('div', {
        cls: 'pagination-container',
        attr: {
            style: 'display: flex; justify-content: center; align-items: center; margin-top: 20px; gap: 10px;'
        }
    });

    const createButton = (text, page, disabled) => {
        const button = paginationContainer.createEl('button', {
            text: text,
            attr: {
                class: 'pagination-btn',
                'data-page': page,
                style: `padding: 5px 10px; ${disabled ? 'opacity: 0.5;' : ''}`,
                ...(disabled ? { disabled: true } : {})
            }
        });
        return button;
    };
    createButton('é¦–é¡µ', 1, currentPage === 1);
    createButton('ä¸Šä¸€é¡µ', currentPage - 1, currentPage === 1);

    paginationContainer.createEl('span', {
        text: `ç¬¬ ${currentPage} é¡µ / å…± ${totalPages} é¡µï¼ˆæ€»è®¡ ${totalItems} æ¡ï¼‰`,
        attr: { style: 'margin: 0 10px;' }
    });

    createButton('ä¸‹ä¸€é¡µ', currentPage + 1, currentPage === totalPages);
    createButton('æœ«é¡µ', totalPages, currentPage === totalPages);

    paginationContainer.querySelectorAll('.pagination-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            if (!e.target.disabled) {
                const newPage = parseInt(e.target.dataset.page);
                await updateCurrentPage(newPage);
                dv.container.dispatchEvent(new CustomEvent('dvjs-update'));
            }
        });
    });

} catch (error) {
    console.error("DataviewæŸ¥è¯¢å‡ºé”™:", error);
    dv.paragraph("âŒ æŸ¥è¯¢æ•°æ®æ—¶å‡ºçŽ°é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ ‡ç­¾æ ¼å¼æˆ–è”ç³»ç®¡ç†å‘˜ã€‚");
    dv.paragraph(`é”™è¯¯è¯¦æƒ…: ${error.message}`);
}

const totalMdNotes = dv.pages(`"${config.areaPath}"`).where(p => p.file.path.endsWith('.md')).length;
```

